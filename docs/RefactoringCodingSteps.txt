Let's put it all together. In your current setup you have three files:

- **inventoryController.js:** Your AJAX caller that makes HTTP requests (GET for selects, POST for edits, etc.)  
- **inventoryActions.php:** A procedural file that handles all inventory actions  
- **inventoryDB_SQL.php:** Your database access layer

We’re going to transform your PHP side into an object‐oriented structure with a dispatcher pattern. This structure splits the code into separate responsibilities. For example, we’ll have:

```
/inventory/
├── controllers/
│   └── InventoryController.php
├── models/
│   └── InventoryModel.php      (formerly inventoryDB_SQL.php)
├── routes/
│   └── dispatcher.php
├── utils/
│   └── Util.php               (if not already OOP, you can update that, too)
├── vendor/                    (composer packages, etc.)
└── inventoryActions.php       (entry point – loads dispatcher)
```

Below are examples for each piece along with explanations.

---

## 1. **InventoryController.php** (in `/controllers/`)

This class will encapsulate all your business logic for inventory actions. Every method corresponds to a task (editing a product, editing a material, etc.). The controller will receive needed dependencies via the constructor (database model, logging, utility functions).

```php
<?php
// File: controllers/InventoryController.php

class InventoryController {
    private $model;
    private $util;
    private $log;

    public function __construct($model, $util, $log) {
        $this->model = $model;
        $this->util  = $util;
        $this->log   = $log;
    }

    // GET: Retrieve inventory list
    public function getInventory() {
        header('Content-Type: application/json');
        $this->log->info("getInventory called");
        $inventory = $this->model->getInventory();
        echo json_encode($inventory);
        exit();
    }

    // GET: Retrieve single record for editing (e.g. editProducts, editMaterials, editPfms)
    public function getRecord() {
        header('Content-Type: application/json');
        if (!isset($_GET['id']) || !isset($_GET['table'])) {
            echo json_encode(["error" => "Missing required parameters"]);
            $this->log->warning("Missing parameters for getRecord");
            exit();
        }
        $id = $_GET['id'];
        $table = $_GET['table'];
        $this->log->info("getRecord called with: $id, $table");
        $record = $this->model->getRecord($id, $table);
        if (!$record) {
            echo json_encode(["error" => "Record not found!"]);
            exit();
        }
        echo json_encode($record, JSON_UNESCAPED_SLASHES | JSON_PRETTY_PRINT);
        exit();
    }

    // POST: Edit product
    public function editProduct($data) {
        if (!isset($data["products"])) {
            http_response_code(400);
            echo "Missing product data!";
            return;
        }
        $result = $this->model->editInventory($data);
        $this->log->info("editProduct result: " . print_r($result, true));
        if ($result["success"]) {
            echo $this->util->showMessage('success', $result['message'] . " Product ID: {$result['product']} updated!");
        } else {
            echo $this->util->showMessage('danger', 'Failed to update product details.');
        }
    }

    // POST: Edit material
    public function editMaterial($data) {
        if (!isset($data["materials"])) {
            http_response_code(400);
            echo "Missing material data!";
            return;
        }
        $result = $this->model->editInventory($data);
        $this->log->info("editMaterial result: " . print_r($result, true));
        if ($result["success"]) {
            echo $this->util->showMessage('success', $result['message'] . " Material: {$result['material']} updated!");
        } else {
            echo $this->util->showMessage('danger', $result['message'] . ' ' . $result['error']);
        }
    }

    // POST: Edit PFM
    public function editPFM($data) {
        if (!isset($data["pfm"])) {
            http_response_code(400);
            echo "Missing PFM data!";
            return;
        }
        $result = $this->model->editInventory($data);
        $this->log->info("editPFM result: " . print_r($result, true));
        if ($result["success"]) {
            echo $this->util->showMessage('success', $result['message'] . " PFM: {$result['pfm']} updated!");
        } else {
            echo $this->util->showMessage('danger', $result['message'] . ' ' . $result['error']);
        }
    }
    
    // Additional methods (e.g., updateProduct or deleteItem) go here...
}
```

*Explanation:*  
Each public method corresponds to an action. Notice the use of headers (for JSON responses) and logging via `$this->log`. The controller delegates database interactions to the model.

---

## 2. **InventoryModel.php** (in `/models/`)

This would be your current `inventoryDB_SQL.php` refactored into a class.

```php
<?php
// File: models/InventoryModel.php

class InventoryModel {
    // Database connection and queries
    public function getInventory() {
        // Example: return array data of inventory items.
        // Replace with actual DB calls.
        return [
            'products'  => [], 
            'materials' => [], 
            'pfms'      => []
        ];
    }

    public function getRecord($id, $table) {
        // Query the specific record by id and table.
        // Return record or false.
        return []; // Example dummy data.
    }

    public function editInventory($data) {
        // Process incoming data to update record in the database.
        // Return an assoc. array such as:
        // [ "success" => true, "message" => "Updated.", "product" => $id ]
        return [
            "success" => true,
            "message" => "Record updated successfully",
            "product" => $data["products"]['productID'] ?? ''
        ];
    }
}
```

*Explanation:*  
This model acts as the data layer. In your real code, connect to your database, prepare queries, and return meaningful values.

---

## 3. **dispatcher.php** (in `/routes/`)

This file acts as the routing dispatcher. It instantiates your controller (using the model, utilities, and logger) and maps actions to the appropriate controller method. In a real project you might expand this to handle GET and POST separately.

```php
<?php
// File: routes/dispatcher.php

require_once __DIR__ . '/../controllers/InventoryController.php';

// Assuming $db, $util, and $log have been initialized in inventoryActions.php
$controller = new InventoryController($db, $util, $log);

// Dispatcher for POST actions – based on the "action" variable in the JSON payload.
if ($_SERVER["REQUEST_METHOD"] === "POST") {
    $data = json_decode(file_get_contents("php://input"), true);
    $log->info("POST Data Received:\n" . print_r($data, true));

    $routes = [
        'editProduct'  => [$controller, 'editProduct'],
        'editMaterial' => [$controller, 'editMaterial'],
        'editPFM'      => [$controller, 'editPFM'],
        // Add additional POST action routes as needed.  
    ];

    $action = $data['action'] ?? null;
    if ($action && isset($routes[$action])) {
        call_user_func($routes[$action], $data);
    } else {
        http_response_code(400);
        echo json_encode(['error' => 'Invalid or missing action']);
    }
    exit();
}

// Dispatcher for GET requests.
if ($_SERVER["REQUEST_METHOD"] === "GET") {
    // We can distinguish based on query parameters.
    if (isset($_GET['getInventory'])) {
        $controller->getInventory();
    } elseif (isset($_GET['editProducts']) || isset($_GET['editMaterials']) || isset($_GET['editPfms'])) {
        $controller->getRecord();
    } else {
        http_response_code(400);
        echo json_encode(['error' => 'Invalid GET request']);
    }
    exit();
}
```

*Explanation:*  
This file creates a mapping (a dispatcher array) that tells the system which controller method to call based on the `"action"` field in your JSON payload for POST. Here, a similar check is applied for GET requests based on parameters (like `getInventory` or `editProducts`). Notice that the dispatcher is the single point of entry—it “dispatches” the request to the proper controller method.

---

## 4. **inventoryActions.php** (Entry Point)

This file is the entry point for all inventory-related requests. It takes care of initializing common utilities, then includes the dispatcher.

```php
<?php
// File: inventoryActions.php

require_once __DIR__ . '/models/InventoryModel.php';
require_once __DIR__ . '/utils/Util.php';
require __DIR__ . '/../../vendor/autoload.php'; // Adjust path as needed

use Monolog\Logger;
use Monolog\ErrorHandler;
use Monolog\Handler\StreamHandler;

// Initialize your inventory model, utilities, and logger
$db = new InventoryModel;
$util = new Util;

$log = new Logger('inventoryActionErrors');
$log->pushHandler(new StreamHandler(__DIR__ . '/logs/inventory_errors.log', Logger::DEBUG)); 
ErrorHandler::register($log);

// Include the dispatcher to handle the request
require_once __DIR__ . '/routes/dispatcher.php';
```

*Explanation:*  
In this entry point you initialize the dependencies (your model, utility class, and logger) and then simply include the dispatcher. The dispatcher now checks the request method (GET or POST) and routes it to the correct controller method.

---

## 5. **InventoryController.js**

Your JavaScript code may remain largely the same since it’s calling your PHP endpoints with parameterized URLs and JSON payloads. Just update your file paths to point to `inventoryActions.php` (or a new route if you change it later—for example, using RESTful URIs). The client-side code continues to make AJAX calls and fills modals accordingly.

---

## Looking Ahead: RESTful Routes

With this structure in place, converting to RESTful endpoints is a small step. Instead of using a single “action” parameter for POSTs, you could define routes like:

- **GET /inventory** to get the full inventory  
- **GET /inventory/{id}** to fetch one product/material/pfm  
- **POST /inventory** to create a new item  
- **PUT /inventory/{id}** to update an item  
- **DELETE /inventory/{id}** to remove an item

Using a library such as [FastRoute](https://github.com/nikic/FastRoute) would allow you to register routes like:

```php
$dispatcher = FastRoute\simpleDispatcher(function(FastRoute\RouteCollector $r) use ($controller) {
    $r->addRoute('GET', '/inventory', [$controller, 'getInventory']);
    $r->addRoute('GET', '/inventory/{id:\d+}', [$controller, 'getRecord']);
    $r->addRoute('POST', '/inventory', [$controller, 'createInventoryItem']);
    $r->addRoute('PUT', '/inventory/{id:\d+}', [$controller, 'updateInventoryItem']);
    $r->addRoute('DELETE', '/inventory/{id:\d+}', [$controller, 'deleteInventoryItem']);
});
```

This RESTful approach would have you extract the HTTP method and URI, dispatch them via FastRoute, and then call the appropriate controller method. The idea is the same—routing the request to the correct function—but with more semantic URLs and HTTP verbs. You can easily evolve your current dispatcher into that style when you’re ready.

---

## Summary

- We have reorganized your procedural PHP into an **OOP controller** (`InventoryController.php`) that uses a **dispatcher pattern** (in `dispatcher.php`) to route request data to the proper action.
- Your **inventoryActions.php** file now acts as an entry point that initializes your dependencies and then defers all routing.
- This design makes it easier to scale, maintain, and eventually evolve to a RESTful API if needed.

Feel free to ask further questions or request additional details on any piece. Happy coding and enjoy your new, modular structure!