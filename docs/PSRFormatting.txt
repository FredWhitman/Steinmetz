Below is a detailed analysis of some common areas where PHP code may stray from the PSR-1/PSR-2 (now merged into PSR-12) standards—and some thoughts on what you might check for in your repository. I haven’t made changes to your GitHub code, but here are specific points you can review and consider adjusting:

---

## **1. File Structure and Declarations**

### **PHP Opening Tags and Strict Types**

- **PSR-1** recommends that files containing only PHP code do not close with a `?>` tag.  
  **Check:** In your files, ensure that you omit the closing tag when the file has PHP only.

- **Strict Typing:** PSR-12 doesn’t mandate it, but it’s considered best practice.  
  **Check:** Consider adding  
  ```php
  declare(strict_types=1);
  ```  
  at the top of each PHP file (especially in libraries/classes) so that type-checking is strict.

### **Namespaces and Classnames**

- **Namespaces:** All class files should declare a namespace that reflects their location in your project. PSR-1 requires that class names follow StudlyCaps, and PSR-4 autoloading usually goes hand in hand with it.  
  **Check:** Verify that your classes have appropriate namespaces and that the namespace hierarchy reflects your directory structure.

- **Class Names:** Class names should follow “StudlyCaps”.  
  **Check:** Ensure your class names and file names are matching and consistently named.

---

## **2. Code Formatting and Indentation**

### **Indentation**

- **Spaces vs. Tabs:** PSR-12 stipulates that you use spaces (typically 4 per indent level).  
  **Check:** Ensure that your repository doesn’t mix tabs and spaces. Many code editors can be set to convert tabs to spaces automatically.

### **Line Length**

- **Maximum Line Length:** Although there’s no hard limit, PSR-12 recommends a soft limit of 120 characters and suggests lines should ideally not exceed 80–120 characters.  
  **Check:** Look in files with long lines (perhaps complex queries or nested functions) and consider breaking them up for readability.

### **Bracing Style and Control Structures**

- **Braces:** PSR-12 specifies that:
  - Opening braces for classes and methods must be on the next line.
  - Control structures (if, for, while, etc.) should have their opening brace on the same line as the statement, but the closing brace must be on its own line.
  
  **Check:** For example, instead of:
  ```php
  if ($condition) {
      // code
  }
  ```
  ensure you’re using consistent spacing before and after braces. Also, ensure you aren’t leaving extra whitespace before a closing brace.

### **Spacing Around Operators and Commas**

- **Operators:** There should be a single space on both sides of assignment (`=`), arithmetic (`+`, `-`, etc.), and comparison operators.  
  **Check:** Look through your code to make sure you write:
  ```php
  $a = $b + $c;
  ```
  rather than something like `$a=$b+$c;`.

- **Commas:** There should be no space before a comma, but there should be one space after.  
  **Check:** In function declarations or arrays, format as:  
  ```php
  function foo($param1, $param2) { ... }
  ```
  rather than `function foo($param1 , $param2)`.

---

## **3. Code Documentation**

### **PHPDoc Comments**

- **Classes, Methods, and Functions:**  
  PSR-5 (although not formally accepted) and general best practices suggest that each class, method, or function should have a PHPDoc block that describes its purpose, parameters, and return values.
  
  **Check:** For example, in your functions (like `CheckProductionRuns`), add PHPDoc-style comments:
  ```php
  /**
   * Checks if there is an open production run for the specified product.
   *
   * @param string $productID The ID of the product.
   * @return bool Returns true if an open production run exists, false otherwise.
   */
  public function CheckProductionRuns($productID) {
      // ... your code ...
  }
  ```
  This not only helps readability but also improves IDE support.

---

## **4. Consistency Across the Codebase**

### **Variable Naming**

- **CamelCase vs. snake_case:** PSR-1 doesn’t force a single naming convention for variable names, but consistency is key.  
  **Check:** If you use camelCase in your methods (e.g., `$productID` or `$prodLogID`), ensure that’s consistent throughout the project. Don’t mix in snake_case (e.g., `$product_id`) unless there is a well-defined rule or legacy reason.

### **Method and Property Visibility**

- **Visibility Keywords:** All methods and properties should have visibility declared (`public`, `protected`, or `private`).  
  **Check:** Look through your classes, and if any method does not have a visibility keyword, add one.

---

## **5. Error Handling and Output Consistency**

- **Return and Error Structures:** While not strictly a PSR issue, having a uniform error response structure in your API endpoints or controllers is important. For example, all JSON responses should follow a consistent structure (e.g., `{'error': false, 'data': ... }` or `{'error': true, 'message':'...' }`).

- **No Accidental Output:** Make sure that files (especially those meant for API responses) have no stray output such as whitespace or debug prints before headers are sent. This goes along with being consistent with PSR-12 recommendations for file formatting.

---

## **Summary**

While your code may already largely work, you can pay attention to these common areas of nonconformance:
- Ensure each PHP file omits the closing `?>` tag when appropriate.
- Use strict declarations and declare consistent namespaces.
- Format your code using spaces for indentation (4 spaces per indent) and ensure your control structures and braces match PSR-12 expectations.
- Document your classes and methods using PHPDoc comments.
- Standardize variable naming and method visibility, ensuring consistency throughout your code.
- Maintain clean output with no stray whitespace and consistent JSON response structures.

Taking time to audit your code for these patterns and updating those areas will not only bring the code closer to the official standards but also improve its readability and maintainability in the long run.

If you’d like more specific, file-by-file insights based on particular examples in your repository, you can share snippets or highlight files you’re most concerned about, and we can review those in detail.