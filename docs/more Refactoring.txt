Below is an example of how you can take the GET and POST blocks from your current procedural code and convert them into an OOP controller that’s invoked via a dispatcher. In this example, the GET requests (for editing materials, PFMs, and updating products) are handled by one or two controller methods, and the POST requests are routed by the dispatcher to their dedicated methods.

Below is a complete walkthrough with code snippets for the new structure.

---

## Folder Structure

A possible folder structure might look like this:

```
/inventory/
├── controllers/
│   └── InventoryController.php
├── models/
│   └── InventoryModel.php      (your former inventoryDB_SQL.php refactored)
├── routes/
│   └── dispatcher.php
├── utils/
│   └── Util.php               (your utility functions)
├── vendor/                    (composer files, etc.)
└── inventoryActions.php       (entry point; bootstraps dependencies and runs dispatcher)
```

---

## 1. Controller Class

In your new OOP controller, you can merge several GET actions together (because they are very similar) into a general method (for example, `getRecord()`) which inspects the query parameters. You can also add separate methods for your POST actions. For example:

**File: controllers/InventoryController.php**
```php
<?php
// controllers/InventoryController.php

class InventoryController {
    private $model;
    private $util;
    private $log;

    public function __construct($model, $util, $log) {
        $this->model = $model;
        $this->util  = $util;
        $this->log   = $log;
    }

    // ---------------------------
    // GET Request Handlers
    // ---------------------------

    // Returns the entire inventory data, called when ?getInventory=1
    public function getInventory() {
        header('Content-Type: application/json');
        $this->log->info("getInventory called");
        $inventory = $this->model->getInventory();
        echo json_encode($inventory);
        exit();
    }

    // Generalized getRecord for edit methods (for products, materials, pfms).
    public function getRecord() {
        header('Content-Type: application/json');

        if (!isset($_GET['id']) || !isset($_GET['table'])) {
            echo json_encode(["error" => "Missing required parameters"]);
            $this->log->warning("Missing parameters in getRecord");
            exit();
        }

        $id = $_GET['id'];
        $table = $_GET['table'];
        $this->log->info("getRecord called with ID: $id, Table: $table");

        // Depending on the GET parameter you might call a different model method.
        // For example, the updateProducts GET uses getInventoryRecord() rather than getRecord()
        if (isset($_GET['updateProducts'])) {
            $record = $this->model->getInventoryRecord($id, $table);
        } else {
            $record = $this->model->getRecord($id, $table);
        }

        if (!$record) {
            echo json_encode(["error" => "Record not found!"]);
            exit();
        }

        // Choose JSON options based on the request (you can refine this logic further)
        $options = isset($_GET['editPfms']) ? (JSON_UNESCAPED_SLASHES | JSON_PRETTY_PRINT) : JSON_FORCE_OBJECT;
        echo json_encode($record, $options);
        exit();
    }

    // ---------------------------
    // POST Request Handlers
    // ---------------------------

    // Edit Product via POST
    public function editProduct($data) {
        if (!isset($data["products"])) {
            http_response_code(400);
            echo "Missing required product data!";
            return;
        }
        $result = $this->model->editInventory($data);
        $this->log->info("editProduct result: " . print_r($result, true));
        if ($result["success"]) {
            echo $this->util->showMessage('success', 
                $result['message'] . " Product ID: {$result['product']} has been updated!");
        } else {
            echo $this->util->showMessage('danger', 'Failed to update product details.');
        }
    }

    // Edit Material via POST
    public function editMaterial($data) {
        if (!isset($data["materials"])) {
            http_response_code(400);
            echo "Missing required material data!";
            return;
        }
        $result = $this->model->editInventory($data);
        $this->log->info("editMaterial result: " . print_r($result, true));
        if ($result["success"]) {
            echo $this->util->showMessage('success', 
                $result['message'] . " Material: {$result['material']} has been updated!");
        } else {
            echo $this->util->showMessage('danger', $result['message'] . ' ' . $result['error']);
        }
    }

    // Edit PFM via POST
    public function editPFM($data) {
        if (!isset($data["pfm"])) {
            http_response_code(400);
            echo "Missing required PFM data!";
            return;
        }
        $result = $this->model->editInventory($data);
        $this->log->info("editPFM result: " . print_r($result, true));
        if ($result['success']) {
            echo $this->util->showMessage('success', 
                $result['message'] . " PFM: {$result['pfm']} has been updated!");
        } else {
            echo $this->util->showMessage('danger', $result['message'] . ' ' . $result['error']);
        }
    }

    // Additional methods (for update, delete, etc.) can be added here.
}
```

*Explanation:*  
• In the controller, the GET actions for editing materials, PFMs, and updating products are combined in the `getRecord()` method. The method uses query parameters (`id` and `table`) to fetch the correct record from your model.  
• The POST actions are separated into methods such as `editProduct()`, `editMaterial()`, and `editPFM()`. These methods receive the decoded JSON payload, perform necessary validations, update through the model, and output a formatted response via your utility class.

---

## 2. Model Class

Your model remains a thin layer to communicate with the database. For example:

**File: models/InventoryModel.php**
```php
<?php
// models/InventoryModel.php

class InventoryModel {
    // Returns a full inventory (products, materials, pfms)
    public function getInventory() {
        // Replace with actual database logic.
        return [
            'products'  => [], 
            'materials' => [], 
            'pfms'      => []
        ];
    }
    
    // Get a record (for products, materials, or pfms)
    public function getRecord($id, $table) {
        // Replace with your actual SELECT query.
        return [
            'id' => $id,
            'table' => $table,
            // ... other fields
        ];
    }
    
    // Special method for updateProducts GET request
    public function getInventoryRecord($id, $table) {
        // Modify this if different than getRecord.
        return $this->getRecord($id, $table);
    }
    
    // Process an edit for Product, Material, or PFM.
    public function editInventory($data) {
        // Process the $data and update the DB.
        // Return an array similar to:
        return [
            "success" => true,
            "message" => "Record updated successfully",
            "product" => $data["products"]['productID'] ?? null,
            "material" => $data["materials"]['matPartNumber'] ?? null,
            "pfm" => $data["pfm"]['pfmID'] ?? null
        ];
    }
}
```

*Explanation:*  
Here the model (formerly your `inventoryDB_SQL.php`) holds methods that interact with your database. In a real implementation, you’d perform the appropriate SQL queries and error handling.

---

## 3. Dispatcher File

This file dispatches incoming requests to the controller. It handles GET and POST methods separately.

**File: routes/dispatcher.php**
```php
<?php
// routes/dispatcher.php

// Instantiate the controller with dependencies.
// (Assuming $db, $util, and $log are already initialized in inventoryActions.php)
require_once __DIR__ . '/../controllers/InventoryController.php';
$controller = new InventoryController($db, $util, $log);

// Handling GET requests.
if ($_SERVER["REQUEST_METHOD"] === "GET") {
    // getInventory
    if (isset($_GET['getInventory'])) {
        $controller->getInventory();
    }
    // editProducts, editMaterials, editPfms, or updateProducts
    elseif (isset($_GET['editProducts']) || isset($_GET['editMaterials'])
            || isset($_GET['editPfms']) || isset($_GET['updateProducts'])) {
        $controller->getRecord();
    } else {
        http_response_code(400);
        echo json_encode(['error' => 'Invalid GET request']);
    }
    exit();
}

// Handling POST requests.
if ($_SERVER["REQUEST_METHOD"] === "POST") {
    $data = json_decode(file_get_contents("php://input"), true);
    $log->info("POST Data Received:\n" . print_r($data, true));

    // Dispatcher mapping for POST actions.
    $routes = [
        'editProduct'  => [$controller, 'editProduct'],
        'editMaterial' => [$controller, 'editMaterial'],
        'editPFM'      => [$controller, 'editPFM'],
        // Add more routes if needed.
    ];

    $action = $data['action'] ?? null;
    if ($action && isset($routes[$action])) {
        call_user_func($routes[$action], $data);
    } else {
        http_response_code(400);
        echo json_encode(['error' => 'Invalid or missing action']);
    }
    exit();
}

// For any unsupported HTTP methods:
http_response_code(405);
echo json_encode(['error' => 'Method Not Allowed']);
exit();
```

*Explanation:*  
• The dispatcher checks the HTTP method.  
• For GET requests, it examines query parameters to decide whether to call `getInventory()` or `getRecord()`.  
• For POST requests, it decodes the incoming JSON and uses the `"action"` field to call the appropriate controller method via a dispatcher array.

---

## 4. Entry Point

Your entry point file loads dependencies, instantiates your model, utility, logger, and then includes the dispatcher.

**File: inventoryActions.php**
```php
<?php
// inventoryActions.php

require_once __DIR__ . '/models/InventoryModel.php';
require_once __DIR__ . '/utils/Util.php';
require __DIR__ . '/../../vendor/autoload.php'; // Adjust path as needed

use Monolog\Logger;
use Monolog\ErrorHandler;
use Monolog\Handler\StreamHandler;

// Initialize dependencies.
$db = new InventoryModel;
$util = new Util;

$log = new Logger('inventoryActionErrors');
$log->pushHandler(new StreamHandler(__DIR__ . '/logs/inventory_errors.log', Logger::DEBUG));
ErrorHandler::register($log);

// Load the dispatcher to handle the request.
require_once __DIR__ . '/routes/dispatcher.php';
```

*Explanation:*  
Here you initialize your model, utility class, and logger. Then you include the `dispatcher.php` file, which will route the request to the appropriate controller function.

---

## 5. JavaScript (inventoryController.js)

Your client-side code can remain largely unchanged, except you may update paths as necessary. The AJAX calls (using fetch) already work with query parameters (for GET) or JSON (for POST) and will now hit your new entry point. For instance, your calls like:
```js
const response = await fetch("../src/classes/inventoryActions.php?getInventory=1", { method: "GET" });
```
will now be routed via your dispatcher into `InventoryController::getInventory()`.

---

## Summary

- **GET Requests:**  
  • `?getInventory=1` is routed to `InventoryController::getInventory()`.  
  • Edit and update requests (where parameters `id` and `table` are provided) are handled by `getRecord()`.

- **POST Requests:**  
  • The JSON payload includes an `"action"` key (for example, `"editProduct"`, `"editMaterial"`, or `"editPFM"`).  
  • A dispatcher array in `dispatcher.php` maps these actions to the appropriate controller methods.  
  • Each controller method validates the incoming data, calls the model for the update, logs the results, and returns a formatted message.

This OOP and dispatcher setup keeps your code organized, maintainable, and ready for future enhancements (for instance, moving toward RESTful routing using tools like FastRoute).

If you have any more questions or need further details on any section, feel free to ask!