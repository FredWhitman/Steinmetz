Below is one way to refactor your code so that a single set of functions works for products, materials, and PFMs. 
The idea is to create a configuration object (or a set of maps) that tells your JavaScript which table uses which DOM IDs, forms, and URL parameters. 
Then you have one generic event listener and one generic form filler. Finally, when you submit the form you include an action field so that your 
back end can switch between editProduct, editMaterial, or editPFM.

Below is an example of how you might refactor your code:

---

### **1. Create a Configuration Object**

Create one object that lists the configuration for each table type. For example, include the container element ID (where your table is rendered), 
field mappings for filling the form, the modal/form IDs you need to update, and even URL parts if needed.

```js
const tableConfigs = {
  products: {
    containerId: "products", // ID of the container/table element
    modalId: "editProductModal", // the modal id for editing products
    formId: "editProductForm",     // the form id used for products
    actionName: "editProduct", // used for posted data
    // Field mappings: keys correspond to database fields returned and names for your form input elements.
    fieldMappings: {
      productID: "hiddenProductID", // hidden input for product id
      partName:   "partName",
      minQty:     "minQty",
      boxesPerSkid: "boxSkid",
      partsPerBox: "partBox",
      partWeight: "partWeight",
      customer:   "customer",
      productionType: "partType",
      displayOrder: "displayOrder",
    },
  },
  materials: {
    containerId: "materials",
    modalId: "editMaterialModal",
    formId: "editMaterialForm",
    actionName: "editMaterial",
    fieldMappings: {
      // The keys should match what your server returns.
      matName:    "matName",
      productID:  "productID", // if you use productID to uniquely identify a material record.
      minLbs:     "minLbs",
      customer:   "mCustomer",
      displayOrder: "mDisplayOrder",
    },
  },
  pfms: {
    containerId: "pfms",
    modalId: "editPFMModal",
    formId: "editPFMForm",
    actionName: "editPFM",
    fieldMappings: {
      // Field names for PFMs
      partNumber: "pNumber",
      partName:   "pName",
      productID:  "pProductID",
      minQty:     "pMinQty",
      customer:   "pCustomer",
      displayOrder: "pDisplayOrder",
    },
  },
};
```

---

### **2. Set Up a Generic Edit Event Listener**

Loop over your configuration and attach one event listener per table container. The listener will look for clicks on links with the class `.editLink` 
and extract the `data-id` from the row.

```js
function setupEditEventListenerForTable(config) {
  document.getElementById(config.containerId).addEventListener("click", (e) => {
    const editLink = e.target.closest("a.editLink");
    if (!editLink) return;
    e.preventDefault();

    let rowElement = editLink.closest("tr");
    let id = rowElement ? rowElement.getAttribute("data-id") : null;

    console.log("Extracted ID:", id, "for table:", config.containerId);
    if (id && id.trim() !== "") {
      // Optionally update the hidden input in the modal form with the id
      let hidden = document.querySelector(`#${config.formId} input[type="hidden"][name="${config.fieldMappings.productID || "productID"}"]`);
      if (hidden) { hidden.value = id.trim(); }

      // Fetch the data and fill the form using the specific table configuration
      fetchAndFillForm(id.trim(), config);
    } else {
      console.error("ERROR: `data-id` is missing or incorrect!");
    }
  });
}

// Initialize listeners for all tables
Object.values(tableConfigs).forEach((config) => setupEditEventListenerForTable(config));
```

---

### **3. Create a Generic Fetch-and-Fill Function**

Use the passed configuration to build the proper URL, fetch the record, and then map each returned value to the form field matching the configuration’s `fieldMappings`.

```js
const fetchAndFillForm = async (id, config) => {
  console.log("Fetching record:", id, " from table:", config.actionName);

  // Example URL: ../src/classes/inventoryActions.php?editProducts=1&id=...
  // Use the actionName property from config to build the query string:
  let url = `../src/classes/inventoryActions.php?${config.actionName}=1&id=${id}&table=${config.actionName.replace("edit", "").toLowerCase()}`;

  try {
    const response = await fetch(url);
    const rawText = await response.text();
    console.log("RAW server response:", rawText);

    const responseData = JSON.parse(rawText);
    console.log("Parsed response:", responseData);
    if (!responseData || responseData.error) {
      console.error("Error from server:", responseData.error);
      return;
    }

    // Fill the form. Use the fieldMappings object
    Object.keys(config.fieldMappings).forEach((dbField) => {
      const formInputId = config.fieldMappings[dbField];
      let element = document.getElementById(formInputId);
      if (element) {
        element.value = responseData[dbField] || "";
      } else {
        console.warn(`Element with ID '${formInputId}' not found!`);
      }
    });

    // Optionally, show the modal if it isn't already shown.
    // For example, if you're using Bootstrap:
    // new bootstrap.Modal(document.getElementById(config.modalId)).show();

  } catch (error) {
    console.error("Failed to fetch and fill form:", error);
  }
};
```

---

### **4. Posting the Data**

When the form is submitted, construct the object with an `action` property. You can have a single submit listener that uses the configuration 
for each type of record, or separate listeners for each form if needed. Here’s an example for one generic handler:

```js
function setupFormSubmit(config) {
  const form = document.getElementById(config.formId);
  form.addEventListener("submit", async (e) => {
    e.preventDefault();
    const formData = new FormData(form);

    // Build the submission data. Here, "products" is replaced by the config.actionName without "edit"
    // For example, for products: { productID: "...", ... }
    const dataKey = config.actionName.replace("edit", "").toLowerCase(); // products, materials or pfm
    let submittedData = {};
    for (let [name, value] of formData.entries()) {
      submittedData[name] = value;
    }
    let payload = {
      action: config.actionName,
      [dataKey]: submittedData,
    };

    console.log("Submitting data:", payload);

    try {
      const response = await fetch("../src/classes/inventoryActions.php", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
      });
      const textResponse = await response.text();
      console.log("Server response on submit:", textResponse);
      // Optionally reset the form, hide the modal, refresh the table, etc.
    } catch (error) {
      console.error("Failed to submit form:", error);
    }
  });
}

// Initialize each form's submit handler
Object.values(tableConfigs).forEach((config) => setupFormSubmit(config));
```

---

### **Summary**

1. **Configuration Object:** Contains key details for each table type (container ID, modal ID, form ID, and field mappings).
2. **Generic Listener:** One function loops through the configurations, attaching a click listener to each table's edit buttons.
3. **fetchAndFillForm():** Accepts an ID and a configuration, builds the proper URL, fetches the current record, then populates 
    the correct form fields based on the mapping.
4. **Form Submission:** A generic submit handler builds the payload and posts it to your PHP handler. Use an `action` field to let
    the server code switch between editing products, materials, or PFMs.

This approach minimizes code duplication and gives you one place to maintain (the configuration object) if you need to change field mappings or form IDs later.

Feel free to adjust the mapping keys and names so they match your server response and your form input names. Let me know if you have any questions or need further refinements!