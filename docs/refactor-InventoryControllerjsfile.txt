Below is one way to break out your large controller file into two modules: one that manages your UI (forms, tables, event listeners, 
and modal filling) and another that handles all your API calls (GET and POST requests). This separation fits nicely with our new PHP 
routing/dispatcher/model setup. You can then load these modules from your main HTML (or via a bundler) so they work together.

---

### 1. **UI Manager (uiManager.js)**

This file is responsible for building tables, wiring up event listeners, and filling modals. For example:

```js
// uiManager.js

// DOM elements
const tbodyProducts = document.getElementById("products");
const editProductForm = document.getElementById("edit-product-form");
const editProductModal = new bootstrap.Modal(document.getElementById("editProductModal"));
const editMaterialForm = document.getElementById("edit-material-form");
const editMaterialModal = new bootstrap.Modal(document.getElementById("editMaterialModal"));
const editPFMForm = document.getElementById("edit-pfm-form");
const editPFMModal = new bootstrap.Modal(document.getElementById("editPFMModal"));
const updateProductForm = document.getElementById("update-product-form");
const updateProductModal = new bootstrap.Modal(document.getElementById("updateProductModal"));
const showAlert = document.getElementById("showAlert"); // Adjust according to your markup

// Loader functions
export function showLoader() {
  const loader = document.getElementById("loader");
  if (loader) loader.classList.remove("d-none");
}

export function hideLoader() {
  const loader = document.getElementById("loader");
  if (loader) loader.classList.add("d-none");
}

// Build HTML for the tables
export function buildProductsTable(products) {
  let html = "";
  products.forEach((row) => {
    // Highlight if below minimum quantity
    let colorStyle =
      row.partQty < row.minQty ? "style='color:red;font-weight: bold;'" : "";
    html += `<tr data-id="${row.productID}">
               <td><span ${colorStyle}>${row.productID}</span></td>
               <td><span ${colorStyle}>${row.partQty}</span></td>
               <td>
                 <a href="#" class="btn btn-primary btn-sm rounded-pill py-0 editLink" title="edit product" data-bs-toggle="modal" data-bs-target="#editProductModal"><i class="bi bi-pencil"></i></a>
                 <a href="#" class="btn btn-success btn-sm rounded-pill py-0 updateLink" title="update product qty" data-bs-toggle="modal" data-bs-target="#updateProductModal"><i class="bi bi-file-earmark-check"></i></a>
               </td>
             </tr>`;
  });
  return html;
}

export function buildMaterialsTable(materials) {
  let html = "";
  materials.forEach((row) => {
    let colorStyle =
      row.matLbs < row.minLbs ? "style='color:red; font-weight:bold;'" : "";
    html += `<tr data-id="${row.matPartNumber}">
               <td><span ${colorStyle}>${row.matName}</span></td>
               <td><span ${colorStyle}>${row.matLbs}</span></td>
               <td>
                 <a href="#" class="btn btn-primary btn-sm rounded-pill py-0 editLink" title="edit material" data-bs-toggle="modal" data-bs-target="#editMaterialModal"><i class="bi bi-pencil"></i></a>
                 <a href="#" class="btn btn-success btn-sm rounded-pill py-0 updateLink" title="update material lbs" data-bs-toggle="modal" data-bs-target="#updateInventoryModal"><i class="bi bi-file-earmark-check"></i></a>
               </td>
             </tr>`;
  });
  return html;
}

export function buildPfmsTable(pfms) {
  let html = "";
  pfms.forEach((row) => {
    let colorStyle = row.Qty < row.minQty ? "style='color:red;font-weight:bold;'" : "";
    html += `<tr data-id="${row.pfmID}">
               <td><span ${colorStyle}>${row.partName}</span></td>
               <td><span ${colorStyle}>${row.Qty}</span></td>
               <td>
                 <a href="#" class="btn btn-primary btn-sm rounded-pill py-0 editLink" title="edit pfm" data-bs-toggle="modal" data-bs-target="#editPFMModal"><i class="bi bi-pencil"></i></a>
                 <a href="#" class="btn btn-success btn-sm rounded-pill py-0 updateLink" title="update pfm qty" data-bs-toggle="modal" data-bs-target="#updatePFMModal"><i class="bi bi-file-earmark-check"></i></a>
               </td>
             </tr>`;
  });
  return html;
}

// Attach a shared event listener for table rows
export function setupEditEventListener(elementId, table) {
  document.getElementById(elementId).addEventListener("click", (e) => {
    const editLink = e.target.closest("a.editLink");
    const updateLink = e.target.closest("a.updateLink");
    if (editLink) {
      e.preventDefault();
      const row = e.target.closest("tr");
      const id = row ? row.getAttribute("data-id") : null;
      if (id && id.trim()) {
        // Dispatch to the API client to fill form
        import("./apiClient.js").then(({ fetchAndFillForm }) => {
          fetchAndFillForm(id.trim(), table);
        });
      }
    }
    if (updateLink) {
      e.preventDefault();
      const row = e.target.closest("tr");
      const id = row ? row.getAttribute("data-id") : null;
      if (id && id.trim()) {
        import("./apiClient.js").then(({ fetchAndFillUpdateForm }) => {
          fetchAndFillUpdateForm(id.trim(), table);
        });
      }
    }
  });
}

// Function to render tables into the DOM
export function renderTables({ products, materials, pfms }) {
  document.getElementById("products").innerHTML = buildProductsTable(products);
  document.getElementById("materials").innerHTML = buildMaterialsTable(materials);
  document.getElementById("pfms").innerHTML = buildPfmsTable(pfms);
}
```

---

### 2. **API Client (apiClient.js)**

This module handles all fetch requests to your PHP entry point, which is now set up with our 
routing/dispatcher. It provides functions for fetching inventory data or submitting forms.

```js
// apiClient.js

import { showLoader, hideLoader } from "./uiManager.js";

// Adjust your base URL/path if needed.
const BASE_URL = "../src/classes/inventoryActions.php";

// Fetch inventory data (GET request)
export async function fetchProductsMaterialPFM() {
  showLoader();
  try {
    const start = performance.now();
    const response = await fetch(`${BASE_URL}?getInventory=1`, { method: "GET" });
    const jsonData = await response.json();
    console.log("Parsed inventory data:", jsonData);
    console.log("Fetch duration:", performance.now() - start);
    hideLoader();
    return jsonData;
  } catch (error) {
    console.error("Error fetching inventory:", error);
    hideLoader();
  }
}

// Fill a form (GET request) for editing
export async function fetchAndFillForm(id, table) {
  const url = `${BASE_URL}?edit${table.charAt(0).toUpperCase() + table.slice(1)}=1&id=${id}&table=${table}`;
  console.log("fetchAndFillForm URL:", url);
  try {
    const response = await fetch(url);
    const rawText = await response.text();
    const responseData = JSON.parse(rawText);
    if (!responseData || responseData.error) {
      console.error("Error from server:", responseData?.error);
      return;
    }
    // Dynamically fill form fields based on table type.
    const fieldMappings = {
      products: {
        productID: "hiddenProductID",
        partName: "partName",
        minQty: "minQty",
        boxesPerSkid: "boxSkid",
        partsPerBox: "partBox",
        partWeight: "partWeight",
        customer: "customer",
        productionType: "partType",
        displayOrder: "displayOrder",
      },
      materials: {
        matPartNumber: "h_matPartNumber",
        matName: "matName",
        productID: "productID",
        minLbs: "minLbs",
        matCustomer: "mCustomer",
        displayOrder: "mDisplayOrder",
      },
      pfms: {
        pfmID: "h_pfmID",
        partNumber: "pNumber",
        partName: "pName",
        productID: "pProductID",
        minQty: "pMinQty",
        customer: "pCustomer",
        displayOrder: "pDisplayOrder",
      },
    };

    Object.keys(fieldMappings[table]).forEach((dbKey) => {
      const formID = fieldMappings[table][dbKey];
      const element = document.getElementById(formID);
      if (element) {
        element.value = responseData[dbKey] || "";
      } else {
        console.warn(`Element with ID '${formID}' not found!`);
      }
    });
  } catch (error) {
    console.error("Failed to parse JSON in fetchAndFillForm:", error);
  }
}

// Fill a form for updating (GET request) - similar logic as above:
export async function fetchAndFillUpdateForm(id, table) {
  const url = `${BASE_URL}?update${table.charAt(0).toUpperCase() + table.slice(1)}=1&id=${id}&table=${table}`;
  console.log("fetchAndFillUpdateForm URL:", url);
  try {
    const response = await fetch(url);
    const rawText = await response.text();
    const responseData = JSON.parse(rawText);
    if (!responseData || responseData.error) {
      console.error("Error from server:", responseData?.error);
      return;
    }
    // Field mappings for update may be different.
    const fieldMappings = {
      products: {
        productID: "h_productID",
        partName: "pPartName",
        partQty: "pStock",
      },
      // Add material and pfm mappings if needed.
    };
    Object.keys(fieldMappings[table]).forEach((dbKey) => {
      const formID = fieldMappings[table][dbKey];
      const element = document.getElementById(formID);
      if (element) {
        element.value = responseData[dbKey] || "";
      } else {
        console.warn(`Element with ID '${formID}' not found in update form!`);
      }
    });
  } catch (error) {
    console.error("Failed to parse JSON in fetchAndFillUpdateForm:", error);
  }
}

// Function to handle a POST request submission:
export async function postData(productData) {
  try {
    const response = await fetch(BASE_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(productData),
    });
    const responseBody = await response.text();
    return responseBody;
  } catch (error) {
    console.error("Error in postData:", error);
    throw error;
  }
}
```

---

### 3. **Putting It All Together in Your Main Script**

You can create a small main file (or include both modules in your HTML) to initialize everything and wire up 
the event listeners. For example, in your HTML you might add:

```html
<script type="module" src="js/uiManager.js"></script>
<script type="module" src="js/apiClient.js"></script>
<script type="module">
  import { renderTables, setupEditEventListener } from "./js/uiManager.js";
  import { fetchProductsMaterialPFM, postData } from "./js/apiClient.js";

  // On page load fetch inventory data and render the tables.
  async function init() {
    const data = await fetchProductsMaterialPFM();
    if (data) {
      renderTables(data);
      // Setup event listeners for all three tables
      setupEditEventListener("products", "products");
      setupEditEventListener("materials", "materials");
      setupEditEventListener("pfms", "pfms");
    }
  }
  init();

  // Add your form submission event listeners here.
  // For example, for editProductForm:
  const editProductForm = document.getElementById("edit-product-form");
  const editProductModal = new bootstrap.Modal(document.getElementById("editProductModal"));
  editProductForm.addEventListener("submit", async (e) => {
    e.preventDefault();
    // Validate and gather formData...
    const formData = new FormData(editProductForm);
    const productData = {
      action: "editProduct",
      products: {
        productID: formData.get("productID"),
        partName: formData.get("p_Part"),
        minQty: formData.get("p_minQty"),
        boxesPerSkid: formData.get("p_boxSkid"),
        partsPerBox: formData.get("p_partBox"),
        partWeight: formData.get("p_partWeight"),
        customer: formData.get("p_customer"),
        displayOrder: formData.get("p_displayOrder"),
        productionType: formData.get("p_partType"),
      },
    };
    try {
      const responseText = await postData(productData);
      document.getElementById("showAlert").innerHTML = responseText;
      editProductForm.reset();
      editProductModal.hide();
      // Optionally refresh the tables...
    } catch (error) {
      console.error("Failed to submit editProduct form:", error);
    }
  });
</script>
```

---

### **Summary**

1. **uiManager.js** handles all DOM tasks—rendering tables and hooking up event listeners that trigger modal population.  
2. **apiClient.js** takes care of sending GET/POST requests to your PHP entry point (which is now routed via our controller, 
dispatcher, and model).  
3. Finally, a small main script (or your HTML module entry point) imports both modules, initializes the UI by fetching data, 
and connects form submissions to POST operations.

This modular approach keeps your code clean and maintainable and fits neatly into your upgraded PHP side using a routing/dispatcher 
and model/controller pattern.

Feel free to adjust the file paths and modals/DOM IDs to match your exact setup!